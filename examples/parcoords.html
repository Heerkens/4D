<!doctype html>
<meta charset="utf-8">
<title>Hypersolid Parallel Coordinates Example</title>
<script src="lib/d3.v3.js"></script>
<script src="lib/d3.parcoords.js"></script>
<script type="text/javascript" src="../hypersolid.js"></script>
<script type="text/javascript" src="../hypersolid.shapebank.js"></script>
<link rel="stylesheet" type="text/css" href="lib/d3.parcoords.css">
<style>
body {
  background: #000;
  color: #f9f9f9;
}
.axis text {
  fill: none;
}
.axis > text {
  fill: #f9f9f9;
}
</style>
<body>
<canvas id="hypercube-canvas">Unfortunately, your browser does not support coolness.</canvas>
<div id="example" class="parcoords" style="width:600px;height:180px"></div>
<pre id="rotations"></pre>
</body>
<script>
var cube = Hypersolid.Hypercube();
Hypersolid.Viewport(cube, document.getElementById('hypercube-canvas'), {
  checkboxes: { 
    perspective: { checked: true },
    indices: { checked: false },
    edges: { checked: true } },
    width: 260,
    height: 260
}).draw();  

  
var pc = d3.parcoords()("#example")
  .dimensions(['x', 'y', 'z', 'w'])
  .data([{x: -2, y: -2, z: -2, w: -2},
         {x: 2, y: 2, z: 2, w: 2}])
  .autoscale();

pc
  .data(cube.getVertices())
  .createAxes()
  .reorderable();

pointLines(cube.getVertices(), cube.getEdges());

d3.select("#rotations")
  .text(JSON.stringify(cube.getRotations(), null, '\t'));

cube.on('rotate', function() {
  var vertices = this.getVertices(); 
  var edges = this.getEdges(); 

  pc.data(vertices);
  
  // intersection points to show edges in ||-coords
  pointLines(vertices, edges);

  d3.select("#rotations")
    .text(JSON.stringify(this.getRotations(), null, '\t'));
});

// Lines -> Points in Parallel Coordinates
function pointLines(vertices, edges) {
  // intersection points to show edges in ||-coords
  var dimensions = pc.dimensions();
  var ctx = pc.ctx.highlight;
  var canvas = pc.canvas.highlight;
  ctx.globalCompositeOperation = "source-over";
  ctx.fillStyle = "rgba(0,0,0,0.1)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.globalCompositeOperation = "lighter";
  ctx.globalAlpha = 0.4;
  ctx.fillStyle = "#f53";
  var pairs = d3.parcoords.adjacent_pairs(dimensions);
  var x = pc.xscale;
  var y = pc.yscale;
  edges.forEach(function(edge) {
    var zig1 = vertices[edge[0]];
    var zig2 = vertices[edge[1]];
    pairs.forEach(function(pair) {
      var dim1 = pair[0];
      var dim2 = pair[1];
      var a = { x: x(dim1), y: y[dim1](zig1[dim1])};
      var b = { x: x(dim2), y: y[dim2](zig1[dim2])};
      var c = { x: x(dim1), y: y[dim1](zig2[dim1])};
      var d = { x: x(dim2), y: y[dim2](zig2[dim2])};
      var point = intersection(a,b,c,d);
      var cx = point.x;
      var cy = point.y;
      if (!isNaN(cx) && !isNaN(cy)) {
        ctx.fillRect(cx-1,cy-1,2,2);
      }
    });
  });  
};

function intersection(a, b, c, d) {
  return {
    x: ((a.x * b.y - a.y * b.x) * (c.x - d.x) - (a.x - b.x) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),
    y: ((a.x * b.y - a.y * b.x) * (c.y - d.y) - (a.y - b.y) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x))
  };
};
</script>
